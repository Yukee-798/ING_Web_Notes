/*
一、闭包基本概念
    1. 如何产生闭包？
        当一个嵌套的内部函数引用了其外部元素的变量/函数时，内部函数就产生了闭包

    2. 闭包是什么？
        理解一：闭包是嵌套的内部函数
        理解二：闭包是嵌套的内部函数中 保存了 在内部函数引用外部变量/函数 的对象

    3. 产生闭包的条件
        (1) 函数嵌套 
        (2) 内部函数引用外部函数的数据
        (3) 执行外部函数：保证内部函数执行定义，内部函数定义完后如果有引用外部函数的数据，其内部就会产生一个闭包对象，保存了引用的这些数据

        function fn1() {
            var a = 3;

            function fn2() {
                console.log(a);
            }
        }

        fn1();
*/


/*

二、常见的闭包
    1. 将函数作为另外一个函数的返回值
        function fn1() {
            var a = 3;

            function fn2() {
                a++;
                console.log(a);
            }
            return fn2;
        }

        var f = fn1();
        f(); // 4
        f(); // 5

        说明： 
            (1) 只调用一次外部函数， 产生了一个内部函数对象(因而只存在一个闭包)
            (2) 内部函数对象作为返回值将其引用传递了出去，没有销毁，闭包也没被销毁，闭包内保存的值也依旧存在

    2. 将函数作为实参传递给另一个函数调用
        function fn1(time) {
            var i = 1;

            setInterval(function() {
                i++;
                console.log(i);
            }, time);
        }

        fn1(2000);

        说明：
            (1) 函数嵌套：外部函数是fn1 ，内部函数是匿名函数 
            (2) 内部函数引用了外部函数的 msg 变量
            (3) 在全局调用了外部函数fn1
            (4) 内部的匿名函数提前定义 ，内部引用了外部函数的数据 i ，产生了闭包对象保存了这个 i
            (5) 由于定时器的作用，每隔 2s 就会执行一次内部函数 
            (6)由于闭包对象的存在 ，始终保存了 i 的值所以会一直累加 

        闭包的作用：
            (1) 使函数内部变量在函数执行完毕后仍然存活在内存中(延迟局部变量生命周期)
            (2) 让函数外部可以去操作函数内部的局部数据


三、闭包的生命周期
    
    1. 闭包的产生和死亡
        (1) 闭包的产生：函数的内部的嵌套函数 引用了外部函数的数据 并 完成了定义 ，此时会在内部函数中产生闭包对象
        (2) 闭包的死亡：函数内部的嵌套函数作为垃圾数据被GC回收


    2. 问题：
        (1) 函数执行完毕后，函数内部的局部变量是否还存在？
            - 一般不存在，只有存在于内部函数的闭包对象中的变量数据才可能延续下去
            - 如果函数内部的函数对象被GC清除，那么闭包对象也会销毁，那么变量数据就不可能延续下去了

        (2) 函数外部可以访问函数内部的变量吗？
            - 一般不能，但是可以通过闭包的机制来操作它

四、闭包的缺点

    1. 缺点：
        (1) 函数执行完后，函数内部的局部变量数据没有被释放，占用内存时间长，如果不及时释放会影响性能
        (2) 容易导致内存泄漏

    2. 解决：
        (1) 及时让内部函数成为垃圾对象被GC回收

    3. 补充一下内存溢出和内存泄漏
        内存溢出：内存溢出是一种程序运行错误，当程序的运行需要的内存超过了剩余的内存时就会抛出内存溢出的错误
        内存泄漏：
            (1) 占用的内存没有被及时释放
            (2) 内存泄漏累积多了就容易出现内存溢出的错误
                    - 意外的全局变量
                    - 没有关闭的循环定时器
                    - 闭包
        
        
    


*/